Why: monitoring how much current a motor draws over time may reveal developing issues like rotor bearing failure, wiring going bad. It will also stop the motor if the rotor has reached its mechanical rotation limits.

You can find the stall current by disconnecting the motor and measuring the winding resistance.  Turn the motor by hand looking for the lowest resistance.  The stall current is the applied voltage ( example 30V ) divided by the (lowest) winding resistance.


Datasheet for the two motor drivers,- that has current monitoring and thermal shutdown.
There also is some mathematical formulas in here:
https://www.ti.com/lit/ds/symlink/drv8251a.pdf?ts=1729018988015&ref_url=https%253A%252F%252Fwww.ti.com%252Fmotor-drivers%252Fbrushed-dc-bdc-drivers%252Fproducts.html


To implement the sub routine for detecting stalled motors using dual DRV8251A and logging statistics, this must be done:

1. Add the necessary variables and constants to the `rotator_features.h` file:
   - `AZ_MOTOR_CURRENT_LIMIT`: Maximum allowed current for the azimuth motor in miliamperes.
   - `EL_MOTOR_CURRENT_LIMIT`: Maximum allowed current for the elevation motor in miliamperes.
   - `MOTOR_STALL_TIME_LIMIT`: Time limit in milliseconds after which a motor is considered stalled.
   - `AZ_MOTOR_STALLED`: Boolean variable to indicate if the azimuth motor is stalled.
   - `EL_MOTOR_STALLED`: Boolean variable to indicate if the elevation motor is stalled.
   - `AZ_MOTOR_CURRENT_SENSE_PIN`: Pin number for measuring the azimuth motor current.
   - `EL_MOTOR_CURRENT_SENSE_PIN`: Pin number for measuring the elevation motor current.
   - `REFERENCE_VOLTAGE`: Reference voltage for the current sense amplifier in volts.
   - `RIPROPI_RESISTOR_OHMS`: Value of the RIPROPI resistors in ohms. There is one per driver, they may be of different value if the motors has different stall current values.
   - `LOGGING_ENABLED`: Boolean variable to enable or disable logging.
   - `SD_CARD_CS_PIN`: Pin number for the SD card chip select.

2. Include the necessary libraries in the `k3ng_rotator_controller.ino` file:
   - `#include <SPI.h>`
   - `#include <SD.h>`

3. Initialize the necessary variables and set up the pins for measuring the motor currents and the SD card in the `setup()` function:
   - Initialize the pins for measuring motor currents.
   - Initialize the SD card using the `SD.begin(SD_CARD_CS_PIN)` function.

4. Create a function `detectMotorStall()` that performs the following steps:
   - Read the current sense values for both azimuth and elevation motors.
   - Calculate the actual current values using the reference voltage and RIPROPI resistors value.
   - Check if the current values exceed the respective limits and the motor has not been stalled before.
   - If a motor's current exceeds its limit and the motor has not been stalled before, check if the stall time limit has been exceeded.
     - If the stall time limit has been exceeded, stop the motor and set the respective stall flag to true.
     - If the stall time limit has not been exceeded, continue monitoring the motor.
   - Display the relevant information and current sensed on the display.

5. Call the `detectMotorStall()` function periodically in the `loop()` function to continuously monitor the motor currents and detect stalls.

6. Create a function `logStatistics()` that performs the following steps:
   - Check if logging is enabled.
   - check if either a time server ( internet) or a GPS is available.
Correct the time.
   - If logging is enabledopen the SD card file in append mode.
   - Write the current sensed, stall status, and timestamp (converted to UTC+0) to the SD card file in CSV format.
   - Close the SD card file.

7. Call the `logStatistics()` function periodically (e.g., every minute) to log the statistics.

8. Maybe put the necessary variables and constants in a file named stalldetection.h ?
RIPROPI_RESISTOR_OHMS_AZ and RIPROPI_RESISTOR_OHMS_EL?

Here's an example implementation of the `detectMotorStall()` and `logStatistics()` functions in Arduino:

```arduino
#include <SPI.h>
#include <SD.h>

#define AZ_MOTOR_CURRENT_LIMIT 500  // miliamperes
#define EL_MOTOR_CURRENT_LIMIT 500  // miliamperes
#define MOTOR_STALL_TIME_LIMIT 5000  // milliseconds
#define AZ_MOTOR_STALLED false
#define EL_MOTOR_STALLED false
#define AZ_MOTOR_CURRENT_SENSE_PIN A0
#define EL_MOTOR_CURRENT_SENSE_PIN A1
#define REFERENCE_VOLTAGE 3.3  // volts
#define RIPROPI_RESISTOR_OHMS 1000.0  // ohms
#define LOGGING_ENABLED true
#define SD_CARD_CS_PIN 10

File sdCardFile;

void setup() {
  // Initialize pins for measuring motor currents
  pinMode(AZ_MOTOR_CURRENT_SENSE_PIN, INPUT);
  pinMode(EL_MOTOR_CURRENT_SENSE_PIN, INPUT);

  // Initialize SD card
  if (SD.begin(SD_CARD_CS_PIN)) {
    Serial.println("SD card initialized");
  } else {
    Serial.println("SD card initialization failed");
  }
}

void loop() {
  detectMotorStall();
  logStatistics();
  // Other code...
}

void detectMotorStall() {
  // Read current sense values
  float azCurrentSense = analogRead(AZ_MOTOR_CURRENT_SENSE_PIN);
  float elCurrentSense = analogRead(EL_MOTOR_CURRENT_SENSE_PIN);

  // Calculate actual current values
  float azCurrent = (azCurrentSense * REFERENCE_VOLTAGE) / (1023.0 * RIPROPI_RESISTOR_OHMS);
  float elCurrent = (elCurrentSense * REFERENCE_VOLTAGE) / (1023.0 * RIPROPI_RESISTOR_OHMS);

  // Check if current values exceed limits and motor has not been stalled before
  if (azCurrent > AZ_MOTOR_CURRENT_LIMIT && !AZ_MOTOR_STALLED) {
    // Check if stall time limit has been exceeded
    if (millis() - lastAzMotorStallTime > MOTOR_STALL_TIME_LIMIT) {
      // Stop azimuth motor and set stall flag
      stopAzMotor();
      AZ_MOTOR_STALLED = true;
      Serial.println("Azimuth motor stalled");
    }
  }

  if (elCurrent > EL_MOTOR_CURRENT_LIMIT && !EL_MOTOR_STALLED) {
    // Check if stall time limit has been exceeded
    if (millis() - lastElMotorStallTime > MOTOR_STALL_TIME_LIMIT) {
      // Stop elevation motor and set stall flag
      stopElMotor();
      EL_MOTOR_STALLED = true;
      Serial.println("Elevation motor stalled");
    }
  }

  // Display relevant information and current sensed on the display
  // ...
}

void logStatistics() {
  if (LOGGING_ENABLED) {
    // Open SD card file in append mode
    sdCardFile = SD.open("statistics.csv", FILE_WRITE);

    if (sdCardFile) {
      // Write current sensed, stall status, and timestamp (converted to UTC+0) to the SD card file in CSV format
      sdCardFile.print(azCurrent);
      sdCardFile.print(",");
      sdCardFile.print(AZ_MOTOR_STALLED);
      sdCardFile.print(",");
      sdCardFile.print(elCurrent);
      sdCardFile.print(",");
      sdCardFile.print(EL_MOTOR_STALLED);
      sdCardFile.print(",");
      sdCardFile.print(getUtcTime());
      sdCardFile.println();

      // Close the SD card file
      sdCardFile.close();
    } else {
      Serial.println("Error opening statistics.csv file");
    }
  }
}

String getUtcTime() {
  // Get the current UTC+0 time in a suitable format (e.g., "YYYY-MM-DD HH:MM:SS")
  // You can use a time library or implement the logic to get the current UTC+0 time
  // Return the UTC+0 time as a string
  // ...
}

void stopAzMotor() {
  // Code to stop the azimuth motor
  // ...
}

void stopElMotor() {
  // Code to stop the elevation motor
  // ...
}
```

Please note that you need to replace the `stopAzMotor()` and `stopElMotor()` functions with the actual code to stop the respective motors. Also, make sure to implement the `getUtcTime()` function to get the current UTC+0 time.

